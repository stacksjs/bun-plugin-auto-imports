import type { Loader, PluginBuilder } from 'bun'
import type { AutoImportsOptions, AutoImportsPlugin, ESLintOptions, ScanDir } from './types'
import { Glob } from 'bun'
import path from 'node:path'
import { generateESLintGlobals } from './eslint'

/**
 * Determines the appropriate Bun loader based on file extension
 * @param filePath The path of the file to load
 * @returns The appropriate Bun loader type
 */
function getLoader(filePath: string): Loader {
  if (filePath.endsWith('.ts'))
    return 'ts'
  if (filePath.endsWith('.js'))
    return 'js'
  if (filePath.endsWith('.tsx'))
    return 'tsx'
  return 'jsx'
}

export const GENERATED_COMMENT = '// Generated by bun-plugin-auto-imports\n'

interface ExportInfo {
  name: string
  file: string
  isType: boolean
  isDefault: boolean
}

/**
 * Scan a directory for all exports with detailed information
 */
async function scanDirExportsDetailed(dir: string, options?: { types?: boolean }): Promise<ExportInfo[]> {
  const exports: ExportInfo[] = []
  const includeTypes = options?.types ?? true

  try {
    const glob = new Glob('**/*.{ts,tsx,js,jsx}')

    for await (const file of glob.scan({
      cwd: dir,
      absolute: true,
      onlyFiles: true,
      followSymlinks: false,
    })) {
      try {
        if (file.includes('node_modules') || file.endsWith('.d.ts')) {
          continue
        }

        const content = await Bun.file(file).text()

        // Match async function exports
        for (const match of content.matchAll(/export\s+async\s+function\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: false })
          }
        }

        // Match regular function exports
        for (const match of content.matchAll(/export\s+function\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: false })
          }
        }

        // Match const/let/var exports
        for (const match of content.matchAll(/export\s+(?:const|let|var)\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: false })
          }
        }

        // Match class exports
        for (const match of content.matchAll(/export\s+class\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: false })
          }
        }

        // Match type/interface exports (if enabled)
        if (includeTypes) {
          for (const match of content.matchAll(/export\s+(?:type|interface)\s+([a-zA-Z_$][\w$]*)/g)) {
            if (match[1]) {
              exports.push({ name: match[1], file, isType: true, isDefault: false })
            }
          }
        }

        // Match export { ... } statements
        for (const match of content.matchAll(/export\s+\{([^}]+)\}/g)) {
          if (match[1]) {
            const names = match[1].split(',').map(n => {
              const trimmed = n.trim()
              // Handle "name as alias" - use the alias
              const asMatch = trimmed.match(/(\S+)\s+as\s+(\S+)/)
              return asMatch ? asMatch[2] : trimmed
            }).filter(n => n && !n.includes('*'))

            for (const name of names) {
              exports.push({ name, file, isType: false, isDefault: false })
            }
          }
        }

        // Match default exports
        for (const match of content.matchAll(/export\s+default\s+(?:async\s+)?(?:function|class)\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: true })
          }
        }
      }
      catch (error: unknown) {
        console.warn(`Warning: Failed to process file ${file}:`, error instanceof Error ? error.message : error)
      }
    }
  }
  catch (error: unknown) {
    console.error(`Error scanning directory ${dir}:`, error instanceof Error ? error.message : error)
    throw new Error(`Failed to scan directory ${dir}: ${error instanceof Error ? error.message : String(error)}`)
  }

  return exports
}

async function scanDirExports(dir: string): Promise<string[]> {
  const detailed = await scanDirExportsDetailed(dir)
  return [...new Set(detailed.map(e => e.name))]
}

/**
 * Generate a runtime index file that re-exports all discovered exports
 * This allows runtime auto-imports by importing this generated file
 */
export async function generateRuntimeIndex(
  dirs: (string | ScanDir)[],
  outputPath: string,
): Promise<{ exports: ExportInfo[], content: string }> {
  const allExports: ExportInfo[] = []

  for (const dir of dirs) {
    const dirPath = typeof dir === 'string' ? dir : dir.path
    const types = typeof dir === 'object' ? dir.types : true
    const exports = await scanDirExportsDetailed(dirPath, { types })
    allExports.push(...exports)
  }

  // Group exports by file
  const exportsByFile = new Map<string, ExportInfo[]>()
  for (const exp of allExports) {
    const existing = exportsByFile.get(exp.file) || []
    existing.push(exp)
    exportsByFile.set(exp.file, existing)
  }

  // Generate import/export statements
  const lines: string[] = [GENERATED_COMMENT]

  for (const [file, exports] of exportsByFile) {
    const relativePath = path.relative(path.dirname(outputPath), file).replace(/\\/g, '/')
    const importPath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`
    // Remove .ts extension for imports
    const cleanPath = importPath.replace(/\.tsx?$/, '')

    const valueExports = exports.filter(e => !e.isType && !e.isDefault)
    const typeExports = exports.filter(e => e.isType)
    const defaultExports = exports.filter(e => e.isDefault)

    if (valueExports.length > 0) {
      lines.push(`export { ${valueExports.map(e => e.name).join(', ')} } from '${cleanPath}'`)
    }

    if (typeExports.length > 0) {
      lines.push(`export type { ${typeExports.map(e => e.name).join(', ')} } from '${cleanPath}'`)
    }

    for (const def of defaultExports) {
      lines.push(`export { default as ${def.name} } from '${cleanPath}'`)
    }
  }

  const content = lines.join('\n') + '\n'
  await Bun.write(outputPath, content)

  return { exports: allExports, content }
}

/**
 * Generate a globals injection script that makes exports available globally
 * This is useful for frameworks that want to make functions available without imports
 */
export async function generateGlobalsScript(
  dirs: (string | ScanDir)[],
  outputPath: string,
  indexPath: string,
): Promise<string> {
  const allExports: ExportInfo[] = []

  for (const dir of dirs) {
    const dirPath = typeof dir === 'string' ? dir : dir.path
    const types = typeof dir === 'object' ? dir.types : true
    const exports = await scanDirExportsDetailed(dirPath, { types })
    allExports.push(...exports)
  }

  // Only include value exports (not types) for global injection
  const valueExports = allExports.filter(e => !e.isType)

  const relativePath = path.relative(path.dirname(outputPath), indexPath).replace(/\\/g, '/')
  const importPath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`
  const cleanPath = importPath.replace(/\.tsx?$/, '')

  const lines: string[] = [
    GENERATED_COMMENT,
    `// This file injects auto-imported functions into the global scope`,
    `// Import this file early in your application startup`,
    ``,
    `import * as autoImports from '${cleanPath}'`,
    ``,
    `// Inject into globalThis for runtime access`,
    `Object.assign(globalThis, autoImports)`,
    ``,
    `// TypeScript declarations`,
    `declare global {`,
  ]

  for (const exp of valueExports) {
    lines.push(`  const ${exp.name}: typeof autoImports.${exp.name}`)
  }

  lines.push(`}`)
  lines.push(``)
  lines.push(`export {}`)
  lines.push(``)

  const content = lines.join('\n')
  await Bun.write(outputPath, content)

  return content
}

/**
 * Generate a standalone TypeScript declaration file for global auto-imports
 * This creates proper type declarations so TypeScript knows about all globals
 */
export async function generateGlobalTypes(
  sources: Array<{ path: string, importFrom: string, types?: boolean }>,
  outputPath: string,
): Promise<string> {
  const allExports: Array<ExportInfo & { importFrom: string }> = []

  for (const source of sources) {
    const exports = await scanDirExportsDetailed(source.path, { types: source.types ?? true })
    for (const exp of exports) {
      allExports.push({ ...exp, importFrom: source.importFrom })
    }
  }

  // Group by import source
  const bySource = new Map<string, typeof allExports>()
  for (const exp of allExports) {
    const existing = bySource.get(exp.importFrom) || []
    existing.push(exp)
    bySource.set(exp.importFrom, existing)
  }

  const lines: string[] = [
    GENERATED_COMMENT,
    `// Global type declarations for auto-imported modules`,
    `// This file is auto-generated - do not edit manually`,
    ``,
  ]

  // Add import type statements for each source
  for (const [importFrom, exports] of bySource) {
    const typeExports = exports.filter(e => e.isType).map(e => e.name)
    const valueExports = exports.filter(e => !e.isType).map(e => e.name)

    if (typeExports.length > 0 || valueExports.length > 0) {
      lines.push(`import type * as _${importFrom.replace(/[^a-zA-Z0-9]/g, '_')} from '${importFrom}'`)
    }
  }

  lines.push(``)
  lines.push(`declare global {`)

  // Add value exports as const declarations
  for (const [importFrom, exports] of bySource) {
    const alias = `_${importFrom.replace(/[^a-zA-Z0-9]/g, '_')}`
    const valueExports = exports.filter(e => !e.isType && !e.isDefault)

    for (const exp of valueExports) {
      lines.push(`  const ${exp.name}: typeof ${alias}.${exp.name}`)
    }
  }

  // Add type exports
  for (const [importFrom, exports] of bySource) {
    const alias = `_${importFrom.replace(/[^a-zA-Z0-9]/g, '_')}`
    const typeExports = exports.filter(e => e.isType)

    for (const exp of typeExports) {
      lines.push(`  type ${exp.name} = ${alias}.${exp.name}`)
    }
  }

  lines.push(`}`)
  lines.push(``)
  lines.push(`export {}`)
  lines.push(``)

  const content = lines.join('\n')
  await Bun.write(outputPath, content)

  return content
}

export function autoImports(options: Partial<AutoImportsOptions>): AutoImportsPlugin {
  return {
    name: 'bun-plugin-auto-imports',

    async setup(builder: PluginBuilder): Promise<void> {
      try {
        const { createUnimport } = await import('unimport')

        // Validate options
        if (options.dirs && !Array.isArray(options.dirs)) {
          throw new Error('options.dirs must be an array')
        }

        // Scan directories for exports
        const dirExports: Record<string, string[]> = {}
        if (options.dirs) {
          for (const dir of options.dirs) {
            const dirPath = typeof dir === 'string' ? dir : ('path' in dir ? dir.path : dir)

            if (!dirPath) {
              console.warn('Warning: Invalid directory configuration found, skipping:', dir)
              continue
            }

            dirExports[dirPath] = await scanDirExports(dirPath)
          }
        }

        // Convert scanned exports to unimport format
        const scannedImports = Object.entries(dirExports).flatMap(([dir, exports]) =>
          exports.map(name => ({
            from: dir,
            name,
            as: name,
          })),
        )

        const dtsPath = path.resolve(options.dts ?? './auto-imports.d.ts')
        const dtsDir = path.dirname(dtsPath)

        const unimport = createUnimport({
          ...options,
          imports: [
            ...(options.imports || []),
            ...scannedImports.map(imp => ({
              ...imp,
              from: `./${path.relative(dtsDir, imp.from).replace(/\\/g, '/')}`,
            })),
          ],
          dts: undefined,
        } as AutoImportsOptions)

        const { injectImports } = unimport

        // Generate types declarations
        const dtsContent = await unimport.generateTypeDeclarations()

        // Add generated comment to d.ts file
        await Bun.write(
          options.dts ?? './auto-imports.d.ts',
          GENERATED_COMMENT + dtsContent,
        )

        if (options.eslint?.enabled === true) {
          const eslintOptions: ESLintOptions = {
            enabled: true,
            filepath: options.eslint.filepath ?? './.eslint-auto-import.json',
            globalsPropValue: options.eslint.globalsPropValue,
          }

          const eslintContent = generateESLintGlobals(dtsContent, eslintOptions)
          await Bun.write(eslintOptions.filepath ?? './.eslint-auto-import.json', eslintContent)
        }

        builder.onLoad({ filter: /.*/ }, async (args) => {
          const fileContent = await Bun.file(args.path).text()
          const transformedFileContent = await injectImports(fileContent)

          return {
            contents: transformedFileContent.code,
            loader: getLoader(args.path) as Loader,
          }
        })
      }
      catch (error: unknown) {
        console.error('Error setting up auto-imports plugin:', error instanceof Error ? error.message : error)
        throw new Error(`Failed to set up auto-imports plugin: ${error instanceof Error ? error.message : String(error)}`)
      }
    },
  }
}

export default autoImports
