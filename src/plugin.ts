import type { Loader, PluginBuilder } from 'bun'
import type { AutoImportsOptions, AutoImportsPlugin, ESLintOptions, ImportItem, InlinePreset, ScanDir } from './types'
import { Glob } from 'bun'
import path from 'node:path'
import { generateESLintGlobals } from './eslint'

/**
 * Determines the appropriate Bun loader based on file extension
 */
function getLoader(filePath: string): Loader {
  if (filePath.endsWith('.ts'))
    return 'ts'
  if (filePath.endsWith('.js'))
    return 'js'
  if (filePath.endsWith('.tsx'))
    return 'tsx'
  return 'jsx'
}

export const GENERATED_COMMENT = '// Generated by bun-plugin-auto-imports\n'

export interface ExportInfo {
  name: string
  file: string
  isType: boolean
  isDefault: boolean
}

// ─── Core Auto-Import Engine ────────────────────────────────────────────────

interface ImportEntry {
  name: string
  as?: string
  from: string
  type: boolean
}

/**
 * Strip comments and string literals from source code so that identifier
 * detection only matches actual code references.
 *
 * - Single-line comments (//)
 * - Multi-line comments (/* ... *​/)
 * - Double-quoted strings ("...")
 * - Single-quoted strings ('...')
 * - Template literals (`...`) — expressions (${...}) are preserved
 *
 * Returns the code with all literal content removed. The result is only
 * used for identifier scanning, not for output.
 */
export function stripLiterals(code: string): string {
  const parts: string[] = []
  let i = 0
  let lastKeepEnd = 0
  const len = code.length

  while (i < len) {
    // Single-line comment
    if (code[i] === '/' && i + 1 < len && code[i + 1] === '/') {
      parts.push(code.slice(lastKeepEnd, i))
      while (i < len && code[i] !== '\n') i++
      lastKeepEnd = i
      continue
    }

    // Multi-line comment
    if (code[i] === '/' && i + 1 < len && code[i + 1] === '*') {
      parts.push(code.slice(lastKeepEnd, i))
      i += 2
      while (i < len && !(code[i] === '*' && i + 1 < len && code[i + 1] === '/')) i++
      if (i < len) i += 2
      lastKeepEnd = i
      continue
    }

    // Template literal
    if (code[i] === '`') {
      parts.push(code.slice(lastKeepEnd, i))
      i++ // skip opening backtick
      while (i < len && code[i] !== '`') {
        if (code[i] === '\\') { i += 2; continue }
        if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
          i += 2
          const exprStart = i
          let depth = 1
          while (i < len && depth > 0) {
            if (code[i] === '\\') { i += 2; continue }
            // Handle strings inside template expressions
            if (code[i] === '"' || code[i] === '\'') {
              const q = code[i]
              i++
              while (i < len && code[i] !== q) {
                if (code[i] === '\\') i++
                i++
              }
              if (i < len) i++
              continue
            }
            // Handle nested template literals inside expressions
            if (code[i] === '`') {
              i++
              while (i < len && code[i] !== '`') {
                if (code[i] === '\\') { i += 2; continue }
                if (code[i] === '$' && i + 1 < len && code[i + 1] === '{') {
                  i += 2
                  let nd = 1
                  while (i < len && nd > 0) {
                    if (code[i] === '{') nd++
                    else if (code[i] === '}') nd--
                    if (nd > 0) i++
                  }
                  if (i < len) i++ // skip closing }
                  continue
                }
                i++
              }
              if (i < len) i++ // skip closing `
              continue
            }
            if (code[i] === '{') depth++
            else if (code[i] === '}') depth--
            if (depth > 0) i++
          }
          // Include the expression content
          parts.push(` ${code.slice(exprStart, i)} `)
          if (i < len) i++ // skip closing }
          continue
        }
        i++
      }
      if (i < len) i++ // skip closing backtick
      lastKeepEnd = i
      continue
    }

    // String literals
    if (code[i] === '"' || code[i] === '\'') {
      parts.push(code.slice(lastKeepEnd, i))
      const quote = code[i]
      i++
      while (i < len && code[i] !== quote) {
        if (code[i] === '\\') i++
        i++
      }
      if (i < len) i++
      lastKeepEnd = i
      continue
    }

    i++
  }

  if (lastKeepEnd < len) {
    parts.push(code.slice(lastKeepEnd))
  }

  return parts.join(' ')
}

/**
 * Detect identifiers in stripped code that exist in the known names set.
 * Uses a negative lookbehind to skip property accesses (obj.foo, obj?.foo).
 */
export function detectUsedIdentifiers(strippedCode: string, knownNames: Set<string>): Set<string> {
  const used = new Set<string>()
  if (knownNames.size === 0) return used

  const regex = /(?<![.\w$])([a-zA-Z_$][\w$]*)/g
  let match
  while ((match = regex.exec(strippedCode)) !== null) {
    if (match[1] && knownNames.has(match[1])) {
      used.add(match[1])
    }
  }
  return used
}

/**
 * Remove identifiers that are already imported in the source code.
 * Handles: named imports, default imports, namespace imports, type imports,
 * and re-exports with `from`.
 */
export function removeAlreadyImported(code: string, usedNames: Set<string>): void {
  const importRegex = /(?:import|export)\s+(?:type\s+)?(?:\{([^}]*)\}|(\*\s+as\s+\w+)|(\w+))(?:\s*,\s*(?:\{([^}]*)\}|(\*\s+as\s+\w+)))?\s+from\s+/g
  let match
  while ((match = importRegex.exec(code)) !== null) {
    // Named imports in first position: import { a, b as c } from '...'
    const namedGroups = [match[1], match[4]]
    for (const group of namedGroups) {
      if (group) {
        for (const part of group.split(',')) {
          const trimmed = part.trim()
          if (!trimmed) continue
          const withoutType = trimmed.replace(/^type\s+/, '')
          const asMatch = withoutType.match(/(\S+)\s+as\s+(\S+)/)
          const localName = asMatch ? asMatch[2] : withoutType
          usedNames.delete(localName)
        }
      }
    }
    // Namespace imports: import * as name from '...'
    const nsGroups = [match[2], match[5]]
    for (const ns of nsGroups) {
      if (ns) {
        const nsMatch = ns.match(/\*\s+as\s+(\w+)/)
        if (nsMatch && nsMatch[1]) usedNames.delete(nsMatch[1])
      }
    }
    // Default import: import name from '...'
    if (match[3] && match[3] !== 'type') {
      usedNames.delete(match[3])
    }
  }
}

/**
 * Remove identifiers that are locally declared in the source code.
 * Handles: const/let/var, function, class, type, interface, enum declarations.
 */
export function removeLocallyDefined(strippedCode: string, usedNames: Set<string>): void {
  const patterns = [
    /(?:export\s+)?(?:async\s+)?function\s+([a-zA-Z_$][\w$]*)/g,
    /(?:export\s+)?(?:const|let|var)\s+([a-zA-Z_$][\w$]*)/g,
    /(?:export\s+)?class\s+([a-zA-Z_$][\w$]*)/g,
    /(?:export\s+)?(?:type|interface)\s+([a-zA-Z_$][\w$]*)/g,
    /(?:export\s+)?enum\s+([a-zA-Z_$][\w$]*)/g,
  ]

  for (const pattern of patterns) {
    let match
    while ((match = pattern.exec(strippedCode)) !== null) {
      if (match[1]) usedNames.delete(match[1])
    }
  }
}

/**
 * Generate import statements grouped by source module.
 * Separates type imports from value imports.
 */
export function generateImportStatements(usedNames: Set<string>, importMap: Map<string, ImportEntry>): string {
  const bySource = new Map<string, { types: string[], values: string[] }>()

  for (const name of usedNames) {
    const entry = importMap.get(name)
    if (!entry) continue
    if (!bySource.has(entry.from)) {
      bySource.set(entry.from, { types: [], values: [] })
    }
    const group = bySource.get(entry.from)!
    const importSpec = entry.as && entry.as !== entry.name
      ? `${entry.name} as ${entry.as}`
      : entry.name

    if (entry.type) {
      group.types.push(importSpec)
    }
    else {
      group.values.push(importSpec)
    }
  }

  const lines: string[] = []
  for (const [source, { types, values }] of bySource) {
    if (values.length > 0) {
      lines.push(`import { ${values.join(', ')} } from '${source}'`)
    }
    if (types.length > 0) {
      lines.push(`import type { ${types.join(', ')} } from '${source}'`)
    }
  }

  return lines.length > 0 ? `${lines.join('\n')}\n` : ''
}

/**
 * The context returned by createAutoImportContext
 */
export interface AutoImportContext {
  importMap: Map<string, ImportEntry>
  knownNames: Set<string>
  injectImports(code: string): { code: string }
  generateTypeDeclarations(): string
}

/**
 * Create an auto-import context from a list of import entries.
 * Returns functions for injecting imports and generating type declarations.
 */
export function createAutoImportContext(entries: ImportEntry[]): AutoImportContext {
  const importMap = new Map<string, ImportEntry>()
  for (const entry of entries) {
    const key = entry.as || entry.name
    // First registration wins (user imports take priority over scanned)
    if (!importMap.has(key)) {
      importMap.set(key, entry)
    }
  }

  const knownNames = new Set(importMap.keys())

  return {
    importMap: importMap,
    knownNames: knownNames,

    injectImports(code: string): { code: string } {
      if (knownNames.size === 0 || !code.trim()) return { code }

      const stripped = stripLiterals(code)
      const usedNames = detectUsedIdentifiers(stripped, knownNames)

      if (usedNames.size === 0) return { code }

      // Remove already-imported names (check original code for import statements)
      removeAlreadyImported(code, usedNames)
      if (usedNames.size === 0) return { code }

      // Remove locally-defined names (check stripped code for declarations)
      removeLocallyDefined(stripped, usedNames)
      if (usedNames.size === 0) return { code }

      const importStatements = generateImportStatements(usedNames, importMap)
      return { code: importStatements + code }
    },

    generateTypeDeclarations(): string {
      const lines: string[] = ['export {}', 'declare global {']

      const sortedEntries = [...importMap.entries()].sort((a, b) => a[0].localeCompare(b[0]))

      for (const [key, entry] of sortedEntries) {
        if (entry.type) {
          lines.push(`  type ${key} = import('${entry.from}')['${entry.name}']`)
        }
        else {
          lines.push(`  const ${key}: typeof import('${entry.from}')['${entry.name}']`)
        }
      }

      lines.push('}')
      return `${lines.join('\n')}\n`
    },
  }
}

/**
 * Resolve presets into flat ImportEntry arrays
 */
function resolvePresets(presets: InlinePreset[]): ImportEntry[] {
  const entries: ImportEntry[] = []
  for (const preset of presets) {
    for (const imp of preset.imports) {
      if (typeof imp === 'string') {
        entries.push({ name: imp, from: preset.from, type: false })
      }
      else {
        entries.push({ name: imp.name, as: imp.as, from: preset.from, type: false })
      }
    }
  }
  return entries
}

/**
 * Convert ImportItem[] to ImportEntry[]
 */
function resolveImports(imports: ImportItem[]): ImportEntry[] {
  return imports.map(imp => ({
    name: imp.name,
    as: imp.as,
    from: imp.from,
    type: imp.type ?? false,
  }))
}

// ─── Directory Scanning ─────────────────────────────────────────────────────

/**
 * Scan a directory for all exports with detailed information
 */
async function scanDirExportsDetailed(dir: string, options?: { types?: boolean }): Promise<ExportInfo[]> {
  const exports: ExportInfo[] = []
  const includeTypes = options?.types ?? true

  try {
    const glob = new Glob('**/*.{ts,tsx,js,jsx}')

    for await (const file of glob.scan({
      cwd: dir,
      absolute: true,
      onlyFiles: true,
      followSymlinks: false,
    })) {
      try {
        if (file.includes('node_modules') || file.endsWith('.d.ts')) {
          continue
        }

        const content = await Bun.file(file).text()

        // Match async function exports
        for (const match of content.matchAll(/export\s+async\s+function\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: false })
          }
        }

        // Match regular function exports
        for (const match of content.matchAll(/export\s+function\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: false })
          }
        }

        // Match const/let/var exports
        for (const match of content.matchAll(/export\s+(?:const|let|var)\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: false })
          }
        }

        // Match class exports
        for (const match of content.matchAll(/export\s+class\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: false })
          }
        }

        // Match type/interface exports (if enabled)
        if (includeTypes) {
          for (const match of content.matchAll(/export\s+(?:type|interface)\s+([a-zA-Z_$][\w$]*)/g)) {
            if (match[1]) {
              exports.push({ name: match[1], file, isType: true, isDefault: false })
            }
          }
        }

        // Match export { ... } statements
        for (const match of content.matchAll(/export\s+\{([^}]+)\}/g)) {
          if (match[1]) {
            const names = match[1].split(',').map((n) => {
              const trimmed = n.trim()
              // Handle "name as alias" - use the alias
              const asMatch = trimmed.match(/(\S+)\s+as\s+(\S+)/)
              return asMatch ? asMatch[2] : trimmed
            }).filter(n => n && !n.includes('*'))

            for (const name of names) {
              exports.push({ name, file, isType: false, isDefault: false })
            }
          }
        }

        // Match default exports
        for (const match of content.matchAll(/export\s+default\s+(?:async\s+)?(?:function|class)\s+([a-zA-Z_$][\w$]*)/g)) {
          if (match[1]) {
            exports.push({ name: match[1], file, isType: false, isDefault: true })
          }
        }
      }
      catch (error: unknown) {
        console.warn(`Warning: Failed to process file ${file}:`, error instanceof Error ? error.message : error)
      }
    }
  }
  catch (error: unknown) {
    console.error(`Error scanning directory ${dir}:`, error instanceof Error ? error.message : error)
    throw new Error(`Failed to scan directory ${dir}: ${error instanceof Error ? error.message : String(error)}`)
  }

  return exports
}

async function scanDirExports(dir: string): Promise<string[]> {
  const detailed = await scanDirExportsDetailed(dir)
  return [...new Set(detailed.map(e => e.name))]
}

/**
 * Generate a runtime index file that re-exports all discovered exports
 */
export async function generateRuntimeIndex(
  dirs: (string | ScanDir)[],
  outputPath: string,
): Promise<{ exports: ExportInfo[], content: string }> {
  const allExports: ExportInfo[] = []

  for (const dir of dirs) {
    const dirPath = typeof dir === 'string' ? dir : dir.path
    const types = typeof dir === 'object' ? dir.types : true
    const exports = await scanDirExportsDetailed(dirPath, { types })
    allExports.push(...exports)
  }

  // Group exports by file
  const exportsByFile = new Map<string, ExportInfo[]>()
  for (const exp of allExports) {
    const existing = exportsByFile.get(exp.file) || []
    existing.push(exp)
    exportsByFile.set(exp.file, existing)
  }

  // Generate import/export statements
  const lines: string[] = [GENERATED_COMMENT]

  for (const [file, exports] of exportsByFile) {
    const relativePath = path.relative(path.dirname(outputPath), file).replace(/\\/g, '/')
    const importPath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`
    // Remove .ts extension for imports
    const cleanPath = importPath.replace(/\.tsx?$/, '')

    const valueExports = exports.filter(e => !e.isType && !e.isDefault)
    const typeExports = exports.filter(e => e.isType)
    const defaultExports = exports.filter(e => e.isDefault)

    if (valueExports.length > 0) {
      lines.push(`export { ${valueExports.map(e => e.name).join(', ')} } from '${cleanPath}'`)
    }

    if (typeExports.length > 0) {
      lines.push(`export type { ${typeExports.map(e => e.name).join(', ')} } from '${cleanPath}'`)
    }

    for (const def of defaultExports) {
      lines.push(`export { default as ${def.name} } from '${cleanPath}'`)
    }
  }

  const content = `${lines.join('\n')}\n`
  await Bun.write(outputPath, content)

  return { exports: allExports, content }
}

/**
 * Generate a globals injection script that makes exports available globally
 */
export async function generateGlobalsScript(
  dirs: (string | ScanDir)[],
  outputPath: string,
  indexPath: string,
): Promise<string> {
  const allExports: ExportInfo[] = []

  for (const dir of dirs) {
    const dirPath = typeof dir === 'string' ? dir : dir.path
    const types = typeof dir === 'object' ? dir.types : true
    const exports = await scanDirExportsDetailed(dirPath, { types })
    allExports.push(...exports)
  }

  // Only include value exports (not types) for global injection
  const valueExports = allExports.filter(e => !e.isType)

  const relativePath = path.relative(path.dirname(outputPath), indexPath).replace(/\\/g, '/')
  const importPath = relativePath.startsWith('.') ? relativePath : `./${relativePath}`
  const cleanPath = importPath.replace(/\.tsx?$/, '')

  const lines: string[] = [
    GENERATED_COMMENT,
    `// This file injects auto-imported functions into the global scope`,
    `// Import this file early in your application startup`,
    ``,
    `import * as autoImports from '${cleanPath}'`,
    ``,
    `// Inject into globalThis for runtime access`,
    `Object.assign(globalThis, autoImports)`,
    ``,
    `// TypeScript declarations`,
    `declare global {`,
  ]

  for (const exp of valueExports) {
    lines.push(`  const ${exp.name}: typeof autoImports.${exp.name}`)
  }

  lines.push(`}`)
  lines.push(``)
  lines.push(`export {}`)
  lines.push(``)

  const content = lines.join('\n')
  await Bun.write(outputPath, content)

  return content
}

/**
 * Generate a standalone TypeScript declaration file for global auto-imports
 */
export async function generateGlobalTypes(
  sources: Array<{ path: string, importFrom: string, types?: boolean }>,
  outputPath: string,
): Promise<string> {
  const allExports: Array<ExportInfo & { importFrom: string }> = []

  for (const source of sources) {
    const exports = await scanDirExportsDetailed(source.path, { types: source.types ?? true })
    for (const exp of exports) {
      allExports.push({ ...exp, importFrom: source.importFrom })
    }
  }

  // Group by import source
  const bySource = new Map<string, typeof allExports>()
  for (const exp of allExports) {
    const existing = bySource.get(exp.importFrom) || []
    existing.push(exp)
    bySource.set(exp.importFrom, existing)
  }

  const lines: string[] = [
    GENERATED_COMMENT,
    `// Global type declarations for auto-imported modules`,
    `// This file is auto-generated - do not edit manually`,
    ``,
  ]

  // Add import type statements for each source
  for (const [importFrom, exports] of bySource) {
    const typeExports = exports.filter(e => e.isType).map(e => e.name)
    const valueExports = exports.filter(e => !e.isType).map(e => e.name)

    if (typeExports.length > 0 || valueExports.length > 0) {
      lines.push(`import type * as _${importFrom.replace(/[^a-zA-Z0-9]/g, '_')} from '${importFrom}'`)
    }
  }

  lines.push(``)
  lines.push(`declare global {`)

  // Add value exports as const declarations
  for (const [importFrom, exports] of bySource) {
    const alias = `_${importFrom.replace(/[^a-zA-Z0-9]/g, '_')}`
    const valueExports = exports.filter(e => !e.isType && !e.isDefault)

    for (const exp of valueExports) {
      lines.push(`  const ${exp.name}: typeof ${alias}.${exp.name}`)
    }
  }

  // Add type exports
  for (const [importFrom, exports] of bySource) {
    const alias = `_${importFrom.replace(/[^a-zA-Z0-9]/g, '_')}`
    const typeExports = exports.filter(e => e.isType)

    for (const exp of typeExports) {
      lines.push(`  type ${exp.name} = ${alias}.${exp.name}`)
    }
  }

  lines.push(`}`)
  lines.push(``)
  lines.push(`export {}`)
  lines.push(``)

  const content = lines.join('\n')
  await Bun.write(outputPath, content)

  return content
}

// ─── Plugin Entry Point ─────────────────────────────────────────────────────

export function autoImports(options: Partial<AutoImportsOptions>): AutoImportsPlugin {
  return {
    name: 'bun-plugin-auto-imports',

    async setup(builder: PluginBuilder): Promise<void> {
      try {
        // Validate options
        if (options.dirs && !Array.isArray(options.dirs)) {
          throw new Error('options.dirs must be an array')
        }

        // Collect all import entries
        const allEntries: ImportEntry[] = []

        // 1. Resolve presets
        if (options.presets) {
          allEntries.push(...resolvePresets(options.presets))
        }

        // 2. Resolve custom imports
        if (options.imports) {
          allEntries.push(...resolveImports(options.imports))
        }

        // 3. Scan directories for exports
        const dtsPath = path.resolve(options.dts ?? './auto-imports.d.ts')
        const dtsDir = path.dirname(dtsPath)

        if (options.dirs) {
          for (const dir of options.dirs) {
            const dirPath = typeof dir === 'string' ? dir : ('path' in dir ? dir.path : dir)

            if (!dirPath) {
              console.warn('Warning: Invalid directory configuration found, skipping:', dir)
              continue
            }

            const exports = await scanDirExportsDetailed(dirPath as string)
            for (const exp of exports) {
              const relativePath = `./${path.relative(dtsDir, exp.file).replace(/\\/g, '/').replace(/\.tsx?$/, '')}`
              allEntries.push({
                name: exp.name,
                from: relativePath,
                type: exp.isType,
              })
            }
          }
        }

        // Create auto-import context
        const context = createAutoImportContext(allEntries)

        // Generate type declarations
        const dtsContent = context.generateTypeDeclarations()

        await Bun.write(
          options.dts ?? './auto-imports.d.ts',
          GENERATED_COMMENT + dtsContent,
        )

        // ESLint integration
        if (options.eslint?.enabled === true) {
          const eslintOptions: ESLintOptions = {
            enabled: true,
            filepath: options.eslint.filepath ?? './.eslint-auto-import.json',
            globalsPropValue: options.eslint.globalsPropValue,
          }

          const eslintContent = generateESLintGlobals(GENERATED_COMMENT + dtsContent, eslintOptions)
          await Bun.write(eslintOptions.filepath ?? './.eslint-auto-import.json', eslintContent)
        }

        // Register onLoad hook
        builder.onLoad({ filter: /.*/ }, async (args) => {
          const fileContent = await Bun.file(args.path).text()
          const result = context.injectImports(fileContent)

          return {
            contents: result.code,
            loader: getLoader(args.path) as Loader,
          }
        })
      }
      catch (error: unknown) {
        console.error('Error setting up auto-imports plugin:', error instanceof Error ? error.message : error)
        throw new Error(`Failed to set up auto-imports plugin: ${error instanceof Error ? error.message : String(error)}`)
      }
    },
  }
}

export default autoImports
