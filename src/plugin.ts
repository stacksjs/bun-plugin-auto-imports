import type { Loader, PluginBuilder } from 'bun'
import type { AutoImportsOptions, AutoImportsPlugin, ESLintOptions } from './types'
import { Glob } from 'bun'
import path from 'node:path'
import { generateESLintGlobals } from './eslint'

/**
 * Determines the appropriate Bun loader based on file extension
 * @param filePath The path of the file to load
 * @returns The appropriate Bun loader type
 */
function getLoader(filePath: string): Loader {
  if (filePath.endsWith('.ts'))
    return 'ts'
  if (filePath.endsWith('.js'))
    return 'js'
  if (filePath.endsWith('.tsx'))
    return 'tsx'
  return 'jsx'
}

export const GENERATED_COMMENT = '// Generated by bun-plugin-auto-imports\n'

async function scanDirExports(dir: string): Promise<string[]> {
  const exports: Set<string> = new Set()

  try {
    // Create glob for TypeScript/JavaScript files
    const glob = new Glob('**/*.{ts,tsx,js,jsx}')

    // Scan the directory for matching files
    for await (const file of glob.scan({
      cwd: dir,
      absolute: true,
      onlyFiles: true,
      followSymlinks: false,
    })) {
      try {
        // Skip definition files and node_modules
        if (file.includes('node_modules') || file.endsWith('.d.ts')) {
          continue
        }

        const content = await Bun.file(file).text()

        // Match export declarations
        const exportMatches = [
          // Named exports
          ...content.matchAll(/export\s+(?:const|let|var|function|class|type|interface)\s+([a-zA-Z_$][\w$]*)/g),
          // Export statements
          ...content.matchAll(/export\s+\{([^}]+)\}/g),
          // Default exports
          ...content.matchAll(/export\s+default\s+(?:(?:function|class)\s*)?([a-zA-Z_$][\w$]*)/g),
        ]

        for (const match of exportMatches) {
          if (match[1]) {
            // Handle multiple exports in a single statement
            const names = match[1].split(',').map(name =>
              name.trim()
                .replace(/\s+as\s+(?:\S.*)?$/, '') // Remove "as" aliases
                .replace(/^.*(?:[\n\r\u2028\u2029]\s*|[\t\v\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF])as\s+/, ''), // Handle "originalName as exportName"
            )
            names.forEach(name => exports.add(name))
          }
        }
      }
      catch (error: unknown) {
        console.warn(`Warning: Failed to process file ${file}:`, error instanceof Error ? error.message : error)
      }
    }
  }
  catch (error: unknown) {
    console.error(`Error scanning directory ${dir}:`, error instanceof Error ? error.message : error)
    throw new Error(`Failed to scan directory ${dir}: ${error instanceof Error ? error.message : String(error)}`)
  }

  return Array.from(exports)
}

export function autoImports(options: Partial<AutoImportsOptions>): AutoImportsPlugin {
  return {
    name: 'bun-plugin-auto-imports',

    async setup(builder: PluginBuilder): Promise<void> {
      try {
        const { createUnimport } = await import('unimport')

        // Validate options
        if (options.dirs && !Array.isArray(options.dirs)) {
          throw new Error('options.dirs must be an array')
        }

        // Scan directories for exports
        const dirExports: Record<string, string[]> = {}
        if (options.dirs) {
          for (const dir of options.dirs) {
            const dirPath = typeof dir === 'string' ? dir : ('path' in dir ? dir.path : dir)

            if (!dirPath) {
              console.warn('Warning: Invalid directory configuration found, skipping:', dir)
              continue
            }

            dirExports[dirPath] = await scanDirExports(dirPath)
          }
        }

        // Convert scanned exports to unimport format
        const scannedImports = Object.entries(dirExports).flatMap(([dir, exports]) =>
          exports.map(name => ({
            from: dir,
            name,
            as: name,
          })),
        )

        const dtsPath = path.resolve(options.dts ?? './auto-imports.d.ts')
        const dtsDir = path.dirname(dtsPath)

        const unimport = createUnimport({
          ...options,
          imports: [
            ...(options.imports || []),
            ...scannedImports.map(imp => ({
              ...imp,
              from: `./${path.relative(dtsDir, imp.from).replace(/\\/g, '/')}`,
            })),
          ],
          dts: undefined,
        } as AutoImportsOptions)

        const { injectImports } = unimport

        // Generate types declarations
        const dtsContent = await unimport.generateTypeDeclarations()

        // Add generated comment to d.ts file
        await Bun.write(
          options.dts ?? './auto-imports.d.ts',
          GENERATED_COMMENT + dtsContent,
        )

        if (options.eslint?.enabled === true) {
          const eslintOptions: ESLintOptions = {
            enabled: true,
            filepath: options.eslint.filepath ?? './.eslint-auto-import.json',
            globalsPropValue: options.eslint.globalsPropValue,
          }

          const eslintContent = generateESLintGlobals(dtsContent, eslintOptions)
          await Bun.write(eslintOptions.filepath ?? './.eslint-auto-import.json', eslintContent)
        }

        builder.onLoad({ filter: /.*/ }, async (args) => {
          const fileContent = await Bun.file(args.path).text()
          const transformedFileContent = await injectImports(fileContent)

          return {
            contents: transformedFileContent.code,
            loader: getLoader(args.path) as Loader,
          }
        })
      }
      catch (error: unknown) {
        console.error('Error setting up auto-imports plugin:', error instanceof Error ? error.message : error)
        throw new Error(`Failed to set up auto-imports plugin: ${error instanceof Error ? error.message : String(error)}`)
      }
    },
  }
}

export default autoImports
